---
layout: post
title: "华为编程规范"
categories: coding
tags : [code style, Huawei]
summary: 编码规范在程序设计中很重要，一个空格，一个字符都是有理由的。
---

一、 排版
------
1. 程序块要采用缩进风格编写，缩进的空格数为4个。  
   说明：对于由开发工具自动生成的代码可以有不一致。

2. 相对独立的程序块之间、变量说明之后必须加空行  
示例：如下例子不符合规范：

        int ni;
        if (!valid_ni(ni))
        {
            ... // program code
        }
        repssn_ind = ssn_data[index].repssn_index;
        repssn_ni  = ssn_data[index].ni;
应如下书写：
        
        int ni;
         
        if (!valid_ni(ni))
        {
            ... // program code
        }
        repssn_ind = ssn_data[index].repssn_index;
        repssn_ni  = ssn_data[index].ni;

3. 较长的语句（>80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。  
示例：

        perm_count_msg.head.len= NO7_TO_STAT_PERM_COUNT_LEN
                                 + STAT_SIZE_PER_FRAM * sizeof( _UL );
        act_task_table[frame_id* STAT_TASK_CHECK_NUMBER + index].occupied
                     = stat_poi[index].occupied;
        act_task_table[taskno].duration_true_or_false
                     = SYS_get_sccp_statistic_state( stat_item );
        report_or_not_flag =((taskno < MAX_ACT_TASK_NUMBER)
                             &&(n7stat_stat_item_valid (stat_item))
                             &&(act_task_table[taskno].result_data != 0));

4. 循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式要在低优先级操作符处划分新行，操作符放在新行之首。

5. 若函数或过程中的参数较长，则要进行适当的划分。
如：

        n7stat_str_compare((BYTE*) & stat_object,
                          (BYTE *) & (act_task_table[taskno].stat_object),
                          sizeof (_STAT_OBJECT));
        n7stat_flash_act_duration(stat_item, frame_id *STAT_TASK_CHECK_NUMBER
                                             + index, stat_object );
6. 不允许把多个短语句写在一行中，即一行只写一条语句.

7. if、for、do、while、case、switch、default等语句自占一行，且if、for、do、while等语句的执行语句部分无论多少都要加括号{}.
示例：如下例子不符合规范.

        if (pUserCR == NULL)return;
应如下书写：

        if (pUserCR == NULL)
        {
           return;
        }
8. 对齐只使用空格键，不使用TAB键.
说明：以免用不同的编辑器阅读程序时，因TAB键所设置的空格数目不同而造成程序布局不整齐，不要使用BC作为编辑器合版本，因为BC会自动将8个空格变为一个TAB键，因此使用BC合入的版本大多会将缩进变乱。(BC: Beyond Compare)

9. 函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case语句下的情况处理语句也要遵从语句缩进要求.

10. 程序块的分界符（如C/C++语言的大括号‘{’和‘}’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类的定义、结构的定义、枚举的定义以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方式.
如：

        for (...)
        {
           ... // program code
        }
        if (...)
        {
           ... // program code
        }
        void example_fun(void )
        {
           ... // program code
        }
11. 在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－>），后不应加空格。  
示例：  
(1). 逗号、分号只在后面加空格。

        int a, b, c; 
(2). 比较操作符, 赋值操作符"="、 "+="，算术操作符"+"、"%"，逻辑操作符"&&"、"&"，位域操作符"<<"、"^"等双目操作符的前后加空格。

        if (current_time >= MAX_TIME_VALUE)
        a = b + c;
        a *= 2;
        a = b ^ 2;
(3). "!"、"~"、"++"、"--"、"&"（地址运算符）等单目操作符前后不加空格。

        *p = 'a';        // 内容操作"*"与内容之间
        flag = !isEmpty; // 非操作"!"与内容之间
        p = &mem;        // 地址操作"&" 与内容之间
        i++;            // "++","--"与内容之间
(4). "->"、"."前后不加空格。

        p->id = pid;     // "->"指针前后不加空格
(5) if、for、while、switch等与后面的括号间应加空格，使if等关键字更为突出、明显。

        if (a >= b && c > d)
 

二、注释
------
1. 一般情况下，源程序有效注释量必须在20％以上。  
说明：注释的原则是有助于对程序的阅读理解，在该加的地方都加了，注释不宜太多也不能太少，注释语言必须准确、易懂、简洁。

2. 说明性文件（如头文件.h文件、.inc文件、.def文件、编译说明文件.cfg等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。 示例：

        /*************************************************
          Copyright (C),1988-1999, Huawei Tech. Co., Ltd.
          Filename:      // 文件名
          Author:      Version:        Date: // 作者、版本及完成日期
          Description:    // 用于详细说明此程序文件完成的主要功能，与其他模块
                         // 或函数的接口，输出值、取值范围、含义及参数间的控
                         // 制、顺序、独立或依赖等关系
          Others:         // 其它内容的说明
          FunctionList:  // 主要函数列表，每条记录应包括函数名及功能简要说明
            1.....
          History:        // 修改历史记录列表，每条修改记录应包括修改日期、修改
                         // 作者及修改内容简述 
            1.Date:
              Author:
              Modification:
            2....
        *************************************************/

3. 源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。  
示例：下面这段源文件的头注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。

        /************************************************************
          Copyright (C),1988-1999, Huawei Tech. Co., Ltd.
          FileName:test.cpp
          Author:        Version:          Date:
          Description:     // 模块描述     
          Version:         // 版本信息
          FunctionList:   // 主要函数及其功能
            1.-------
          History:         // 历史修改记录
             <author>  <time>   <version >  <desc>
             David    96/10/12    1.0     build this moudle 
        ***********************************************************/
说明：Description一项描述本文件的内容、功能、内部各部分之间的关系及本文件与其它文件关系等。History是修改历史记录列表，每条修改记录应包括修改日期、修改者及修改内容简述。

4. 函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。  
示例：下面这段函数的注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。

        /*************************************************
         Function:       // 函数名称
         Description:    // 函数功能、性能等的描述
         Calls:          // 被本函数调用的函数清单
         CalledBy:      // 调用本函数的函数清单
         TableAccessed: // 被访问的表（此项仅对于牵扯到数据库操作的程序）
         TableUpdated:  // 被修改的表（此项仅对于牵扯到数据库操作的程序）
         Input:          // 输入参数说明，包括每个参数的作
                         // 用、取值说明及参数间关系。
         Output:         // 对输出参数的说明。
         Return:         // 函数返回值的说明
         Others:         // 其它说明
        *************************************************/

5. 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。

6. 注释的内容要清楚、明了，含义准确，防止注释二义性

7. 避免在注释中使用缩写，特别是非常用缩写。

8. 注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。

9. 对于所有有物理含义的变量、常量，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释应放在其上方相邻位置或右方。  
示例：

        /* active statistictask number */
        #defineMAX_ACT_TASK_NUMBER 1000
        #defineMAX_ACT_TASK_NUMBER 1000 /* active statistic task number */
10. 数据结构声明(包括数组、结构、类、枚举等)，如果其命名不是充分自注释的，必须加以注释。对数据结构的注释应放在其上方相邻位置，不可放在下面；对结构中的每个域的注释放在此域的右方。  
示例：可按如下形式说明枚举/数据/联合结构。

        /* sccp interfacewith sccp user primitive message name */
        enum  SCCP_USER_PRIMITIVE
        {
           N_UNITDATA_IND, /* sccp notify sccp user unit data come */
           N_NOTICE_IND,   /* sccp notify user the No.7 network can not */
                           /* transmission this message */
           N_UNITDATA_REQ, /* sccp user's unit data transmission request*/
        };

11. 全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。  
示例：

        /* The ErrorCode whenSCCP translate */
        /* Global Titlefailure, as follows */      // 变量作用、含义
        /* 0 － SUCCESS   1 － GT Table error */
        /* 2 － GT error  Others － no use */       // 变量取值范围
        /* only  function SCCPTranslate() in */
        /* this modual canmodify it,  and  other */
        /* module can visitit through call */
        /* the  functionGetGTTransErrorCode() */    // 使用方法
        BYTE g_GTTranErrorCode; 
12. 注释与所描述内容进行同样的缩排。

13. 将注释与其上面的代码用空行隔开。

14. 对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。

15. 对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。

16. 避免在一行代码或表达式的中间插入注释。

17. 通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。

18. 在程序块的结束行右方加注释标记，以表明某程序块的结束。

19. 注释格式尽量统一，建议使用 

        /* …… */

20. 注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。


三、标识符命名
------
1. 标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。  
说明：较短的单词可通过去掉“元音”形成缩写；较长的单词可取单词的头几个字母形成缩写；一些单词有大家公认的缩写。  
示例：如下单词的缩写能够被大家基本认可。
temp 可缩写为  tmp  ;  
flag 可缩写为  flg  ;  
statistic 可缩写为  stat ;  
increment 可缩写为  inc  ;  
message 可缩写为  msg  ;  

2. 命名中若使用特殊约定或缩写，则要有注释说明。

3. 自己特有的命名风格，要自始至终保持一致，不可来回变化。  
说明：个人的命名风格，在符合所在项目组或产品组的命名规则的前提下，才可使用。（即命名规则中没有规定到的地方才可有个人命名风格）。

4. 对于变量命名，禁止取单个字符（如i、j、k...），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i、j、k作局部循环变量是允许的。

5. 命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用UNIX的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识如标识成员变量或全局变量的m_和g_，其后加上大小写混排的方式是允许的。

6. 除非必要，不要用数字或较奇怪的字符来定义标识符。

7. 在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。

8. 用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。  
说明：下面是一些在软件中常用的反义词组。

        add /remove       begin /end        create / destroy
        insert /delete       first /last         get / release
        increment /decrement                put / get
        add /delete         lock /unlock      open / close
        min /max          old /new         start / stop
        next /previous      source / target    show / hide
        send /receive       source / destination
        cut /paste          up / down

9. 除了编译开关/头文件等特殊应用，应避免使用_EXAMPLE_TEST_之类以下划线开始和结尾的定义


四、可读性
------
1. 注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。

2. 避免使用不易理解的数字，用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。  
示例：如下的程序可读性差。

        if(Trunk[index].trunk_state == 0)
        {
           Trunk[index].trunk_state = 1;
           ...  // program code
        }
应改为如下形式。

        #define TRUNK_IDLE 0
        #define TRUNK_BUSY 1
        if(Trunk[index].trunk_state == TRUNK_IDLE)
        {
           Trunk[index].trunk_state = TRUNK_BUSY;
           ...  // program code
        }

3. 源程序中关系较为紧密的代码应尽可能相邻。

4. 不要使用难懂的技巧性很高的语句，除非很有必要时。  
说明：高技巧语句不等于高效率的程序，实际上程序的效率关键在于算法。


五、变量、结构
------
1. 去掉没必要的公共变量。

2. 仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。

3. 明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。

4. 当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。

5. 防止局部变量与公共变量同名。

6. 严禁使用未经初始化的变量作为右值。  
说明：特别是在C/C++中引用未经赋值的指针，经常会引起系统崩溃。

7. 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的公共变量，防止多个不同模块或函数都可以修改、创建同一公共变量的现象。

8. 使用严格形式定义的、可移植的数据类型，尽量不要使用与具体硬件或软件环境关系密切的变量。

9. 结构的功能要单一，是针对一种事务的抽象。

10. 不要设计面面俱到、非常灵活的数据结构。

11. 不同结构间的关系不要过于复杂。

12. 结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。

13. 仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。

14. 结构的设计要尽量考虑向前兼容和以后的版本升级，并为某些未来可能的应用保留余地（如预留一些空间等）。

15. 留心具体语言及编译器处理不同数据类型的原则及有关细节。

16. 编程时，要注意数据类型的强制转换。

17. 对编译系统默认的数据类型转换，也要有充分的认识。

18. 尽量减少没有必要的数据类型默认转换与强制转换。

19. 合理地设计数据并使用自定义数据类型，避免数据间进行不必要的类型转换。

20. 对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。

21. 当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序、使用的位域及字节对齐等问题。

六、函数、过程
------
1. 对所调用函数的错误返回码要仔细、全面地处理。

2. 明确函数功能，精确（而不是近似）地实现函数设计。

3. 编写可重入函数时，应注意局部变量的使用（如编写C/C++语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量）。

4. 编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。  
说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。

5. 在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。

6. 防止将函数的参数作为工作变量。  
 说明：将函数的参数作为工作变量，有可能错误地改变参数内容，所以很危险。对必须改变的参数，最好先用局部变量代之，最后再将该局部变量的内容赋给该参数。

7. 函数的规模尽量限制在200行以内。

8. 一个函数仅完成一件功能。

9. 为简单功能编写函数。

10. 不要设计多用途面面俱到的函数。

11. 函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。

12. 尽量不要编写依赖于其他函数内部实现的函数。

13. 避免设计多参数函数，不使用的参数从接口中去掉。

14. 非调度函数应减少或防止控制参数，尽量只使用数据参数。

15. 检查函数所有参数输入的有效性。

16. 检查函数所有非参数输入的有效性，如数据文件、公共变量等。

17. 函数名应准确描述函数的功能。

18. 使用动宾词组为执行某操作的函数命名。如果是OOP方法，可以只有动词（名词是对象本身）。

19. 避免使用无意义或含义不清的动词为函数命名。

20. 函数的返回值要清楚、明了，让使用者不容易忽视错误情况。

21. 除非必要，最好不要把与函数返回值类型不同的变量，以编译系统默认的转换方式或强制的转换方式作为返回值返回。

22. 让函数在调用点显得易懂、容易理解。

23. 在调用函数填写参数时，应尽量减少没有必要的默认数据类型转换或强制数据类型转换。

24. 避免函数中不必要语句，防止程序中的垃圾代码。

25. 防止把没有关联的语句放到一个函数中。

26. 如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。

27. 功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。

28. 设计高扇入、合理扇出（小于7）的函数。  
说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。

29. 减少函数本身或函数间的递归调用。

30. 仔细分析模块的功能及性能需求，并进一步细分，同时若有必要画出有关数据流图，据此来进行模块的函数划分与组织。

31. 改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。

32. 在多任务操作系统的环境下编程，要注意函数可重入性的构造。  
说明：可重入性是指函数可以被多个任务进程调用。在多任务操作系统中，函数是否具有可重入性是非常重要的，因为这是多个进程可以共用此函数的必要条件。另外，编译器是否提供可重入函数库，与它所服务的操作系统有关，只有操作系统是多任务时，编译器才有可能提供可重入函数库。如DOS下BC和MSC等就不具备可重入函数库，因为DOS是单用户单任务操作系统。

33. 避免使用BOOL参数。
说明：原因有二，其一是BOOL参数值无意义，TURE/FALSE的含义是非常模糊的，在调用时很难知道该参数到底传达的是什么意思；其二是BOOL参数值不利于扩充。还有NULL也是一个无意义的单词。。

34. 对于提供了返回值的函数，在引用时最好使用其返回值。

35. 当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。


七、可测性
------
1. 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。

2. 在同一项目组或产品组内，调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名（或源文件名）及行号。

3. 编程的同时要为单元测试选择恰当的测试点，并仔细构造测试代码、测试用例，同时给出明确的注释说明。测试代码部分应作为（模块中的）一个子模块，以方便测试代码在模块中的安装与拆卸（通过调测开关）。

4. 在进行集成测试/系统联调之前，要构造好测试环境、测试项目及测试用例，同时仔细分析并优化测试用例，以提高测试效率。

5. 使用断言来发现软件问题，提高代码可测性。

6. 用断言来检查程序正常运行时不应发生但在调测时有可能发生的非法情况。

7. 不能用断言来检查最终产品肯定会出现且必须处理的错误情况。

8. 对较复杂的断言加上明确的注释。  
如：

        #ifdef _EXAM_ASSERT_TEST_  // 若使用断言测试
        void exam_assert(char * file_name, unsigned int line_no )
        {
           printf( "\n[EXAM]Assert failed: %s, line %u\n",
                   file_name, line_no );
            abort();
        }
        #define EXAM_ASSERT( condition )
            if(condition) // 若条件成立，则无动作
               NULL;
           else  // 否则报告
               exam_assert( __FILE__, __LINE__ ) 
        #else  // 若不使用断言测试
        #define EXAM_ASSERT(condition)  NULL
        #endif  /* end of ASSERT */

9. 用断言保证没有定义的特性或功能不被使用。

10. 用断言对程序开发环境（OS/Compiler/Hardware）的假设进行检查。

11. 正式软件产品中应把断言及其它调测代码去掉（即把有关的调测开关关掉）。

12. 在软件系统中设置与取消有关测试手段，不能对软件实现的功能等产生影响。

13. 用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。

14. 软件的DEBUG版本和发行版本应该统一维护，不允许分家，并且要时刻注意保证两个版本在实现功能上的一致性。

15. 在编写代码之前，应预先设计好程序调试与测试的方法和手段，并设计好各种调测开关及相应测试代码如打印函数等。

16. 调测开关应分为不同级别和类型。

17. 编写防错程序，然后在处理错误之后可用断言宣布发生错误。


八、效率
------
1. 编程时要经常注意代码的效率。  
说明：代码效率分为全局效率、局部效率、时间效率及空间效率。全局效率是站在整个系统的角度上的系统效率；局部效率是站在模块或函数角度上的效率；时间效率是程序处理输入任务所需的时间长短；空间效率是程序所需内存空间，如机器代码空间大小、数据空间大小、栈空间大小等。

2. 在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。

3. 局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。

4. 通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。

5. 循环体内工作量最小化。

6. 仔细分析有关算法，并进行优化。

7. 仔细考查、分析系统及模块处理输入（如事务、消息等）的方式，并加以改进。

8. 对模块中函数的划分及组织方式进行分析、优化，改进模块中函数的组织结构，提高程序效率。  
说明：软件系统的效率主要与算法、处理任务方式、系统功能及函数结构有很大关系，仅在代码上下功夫一般不能解决根本问题。

9. 编程时，要随时留心代码效率；优化代码时，要考虑周全。

10. 不应花过多的时间拼命地提高调用不很频繁的函数代码效率。

11. 要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。

12. 在保证程序质量的前提下，通过压缩代码量、去掉不必要代码以及减少不必要的局部和全局变量，来提高空间效率。

13. 在多重循环中，应将最忙的循环放在最内层。  
说明：减少CPU切入循环层的次数。  
示例：如下代码效率不高。

        for (row = 0; row< 100; row++)
        {
           for (col = 0; col < 5; col++)
            {
               sum += a[row][col];
            }
        }
可以改为如下方式，以提高效率。

        for (col = 0; col< 5; col++)
        {
           for (row = 0; row < 100; row++)
            {
               sum += a[row][col];
            }
        }
14. 尽量减少循环嵌套层次。

15. 避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。

16. 尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。

17. 不要一味追求紧凑的代码。  
说明：因为紧凑的代码并不代表高效的机器码。


九、质量保证
------
1. 在软件设计过程中构筑软件质量。

2. 代码质量保证优先原则。  
    （1）正确性，指程序要实现设计要求的功能。  
    （2）稳定性、安全性，指程序稳定、可靠、安全。  
    （3）可测试性，指程序要具有良好的可测试性。  
    （4）规范/可读性，指程序书写风格、命名规则等要符合规范。  
    （5）全局效率，指软件系统的整体效率。  
    （6）局部效率，指某个模块/子模块/函数的本身效率。  
    （7）个人表达方式/个人方便性，指个人编程习惯。  

3. 只引用属于自己的存贮空间。

4. 防止引用已经释放的内存空间。

5. 过程/函数中分配的内存，在过程/函数退出之前要释放。

6. 过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。  
示例：下函数在退出之前，没有把分配的内存释放。

        typedef unsigned char BYTE;
        int example_fun( BYTE gt_len, BYTE *gt_code )
        {
           BYTE *gt_buf;
           gt_buf = (BYTE *) malloc (MAX_GT_LENGTH);
           ...  //program code, include check gt_buf if or not NULL.
            /*global title length error */
            if(gt_len > MAX_GT_LENGTH)
            {
               return GT_LENGTH_ERROR; // 忘了释放gt_buf
            }
           ...  // other program code
        }
应改为如下。

        int example_fun( BYTE gt_len, BYTE *gt_code )
        {
           BYTE *gt_buf;
           gt_buf = (BYTE * ) malloc ( MAX_GT_LENGTH );
           ...  // program code, include check gt_buf if or not NULL.
            /*global title length error */
            if(gt_len > MAX_GT_LENGTH)
            {
               free( gt_buf  ); // 退出之前释放gt_buf
               return GT_LENGTH_ERROR; 
            }
           ...  // other program code
        }

7. 防止内存操作越界。

8. 认真处理程序所能遇到的各种出错情况。

9. 系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。

10. 系统运行之初，要对加载到系统中的数据进行一致性检查。

11. 严禁随意更改其它模块或系统的有关设置和配置。

12. 不能随意改变与其它模块的接口。

13. 充分了解系统的接口之后，再使用系统提供的功能。

14. 编程时，要防止差1错误。  
说明：此类错误一般是由于把“<=”误写成“<”或“>=”误写成“>”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。当编完程序后，应对这些操作符进行彻底检查。

15. 要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。

16. 有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。

17. Unix下，多线程的中的子线程退出必需采用主动退出方式，即子线程应return出口。

18. 不要滥用goto语句。

19. 不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。

20. 除非为了满足特殊需求，避免使用嵌入式汇编。

21. 精心地构造、划分子模块，并按“接口”部分及“内核”部分合理地组织子模块，以提高“内核”部分的可移植性和可重用性。

22. 精心构造算法，并对其性能、效率进行测试。

23. 对较关键的算法最好使用其它算法来确认。

24. 时刻注意表达式是否会上溢、下溢。

25. 使用变量时要注意其边界值的情况。

26. 留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。

27. 为用户提供良好的接口界面，使用户能较充分地了解系统内部运行状态及有关系统出错情况。

28. 系统应具有一定的容错能力，对一些错误事件（如用户误操作等）能进行自动补救。

29. 对一些具有危险性的操作代码（如写硬盘、删数据等）要仔细考虑，防止对数据、硬件等的安全构成危害，以提高系统的安全性。

30. 使用第三方提供的软件开发工具包或控件时，要注意以下几点：  
（1）充分了解应用接口、使用环境及使用时注意事项。  
（2）不能过分相信其正确性。  
（3）除非必要，不要使用不熟悉的第三方工具包与控件。  
说明：使用工具包与控件，可加快程序开发速度，节省时间，但使用之前一定对它有较充分的了解，同时第三方工具包与控件也有可能存在问题。

31. 资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）。


十、代码编辑、编译、审查
------
1. 打开编译器的所有告警开关对程序进行编译。

2. 在产品软件（项目组）中，要统一编译开关选项。

3. 通过代码走读及审查方式对代码进行检查。  
说明：代码走读主要是对程序的编程风格如注释、命名等以及编程时易出错的内容进行检查，可由开发人员自己或开发人员交叉的方式进行；代码审查主要是对程序实现的功能及程序的稳定性、安全性、可靠性等进行检查及评审，可通过自审、交叉审核或指定部门抽查等方式进行。

4. 测试部测试产品之前，应对代码进行抽查及评审。

5. 编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。

6. 同产品软件（项目组）内，最好使用相同的编辑器，并使用相同的设置选项。

7. 要小心地使用编辑器提供的块拷贝功能编程。  
说明：当某段代码与另一段代码的处理功能相似时，许多开发人员都用编辑器提供的块拷贝功能来完成这段代码的编写。由于程序功能相近，故所使用的变量、采用的表达式等在功能及命名上可能都很相近，所以使用块拷贝时要注意，除了修改相应的程序外，一定要把使用的每个变量仔细查看一遍，以改成正确的。不应指望编译器能查出所有这种错误，比如当使用的是全局变量时，就有可能使某种错误隐藏下来。

8. 合理地设计软件系统目录，方便开发人员使用.

9. 某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。
说明：在Borland C/C++中，可用“#pragma  warn”来关掉或打开某些告警。

        #pragma warn -rvl // 关闭告警
        int examples_fun(void )
        {
             // 程序，但无return语句。
        }
        #pragma warn +rvl // 打开告警

10. 使用代码检查工具（如C语言用PC-Lint）对源程序检查。

11. 使用软件工具（如 LogiSCOPE）进行代码审查。


十一、代码测试、维护
-----
1. 单元测试要求至少达到语句覆盖。

2. 单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。

3. 清理、整理或优化后的代码要经过审查及测试。

4. 代码版本升级要经过严格测试。

5. 使用工具软件对代码版本进行维护。

6. 正式版本上软件的任何修改都应有详细的文档记录。

7. 发现错误立即修改，并且要记录下来。

8. 关键的代码在汇编级跟踪。

9. 仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。

10. 尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。

11. 仔细测试代码处理数据、变量的边界情况。

12. 保留测试信息，以便分析、总结经验及进行更充分的测试。

13. 不应通过“试”来解决问题，应寻找问题的根本原因。

14. 对自动消失的错误进行分析，搞清楚错误是如何消失的。

15. 修改错误不仅要治表，更要治本。

16. 测试时应设法使很少发生的事件经常发生。

17. 明确模块或函数处理哪些事件，并使它们经常发生。

18. 坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题。

19. 去除代码运行的随机性（如去掉无用的数据、代码及尽可能防止并注意函数中的“内部寄存器”等），让函数运行的结果可预测，并使出现的错误可再现。


参考
---------------
http://blog.csdn.net/ce123_zhouwei/article/details/8885868 
http://blog.csdn.net/ce123_zhouwei/article/details/8885964 
http://blog.csdn.net/ce123_zhouwei/article/details/8886016 
http://blog.csdn.net/ce123_zhouwei/article/details/8886277 
http://blog.csdn.net/ce123_zhouwei/article/details/8886504 
http://blog.csdn.net/ce123_zhouwei/article/details/8887863 
http://blog.csdn.net/ce123_zhouwei/article/details/8888977 
http://blog.csdn.net/ce123_zhouwei/article/details/8888467 
http://blog.csdn.net/ce123_zhouwei/article/details/8889058 
http://blog.csdn.net/ce123_zhouwei/article/details/8889071 
http://blog.csdn.net/ce123_zhouwei/article/details/8889076 
